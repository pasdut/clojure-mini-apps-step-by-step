#+STARTUP: content
#+hugo_base_dir: ./hugo/

# The files will be saved in <hugo_base_dir>/content/<hugo_section>/<concatenated values of EXPORT_HUGO_SECTION_FRAG>
#+hugo_section: posts

* HOME
:PROPERTIES:
:EXPORT_HUGO_SECTION:/
:EXPORT_FILE_NAME: _index
:END:
Is dit de HOME ?
Is dit de HOME ?
Is dit de HOME ?
Is dit de HOME ?
** SQL Inspector : Clojure + JDBC + JavaFX Desktop application
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_SECTION_FRAG: sql-inspector
:END:
Dit is de home van SQL Inspector
Dit is de home van SQL Inspector
Dit is de home van SQL Inspector
Dit is de home van SQL Inspector
Dit is de home van SQL Inspector

*** SQL Inspector : Part 1
:PROPERTIES:
:EXPORT_FILE_NAME: part1
:END:
**** What?
"SQL Inspector" is a desktop application written in Clojure.  It shows all tables of a database. There is a textbox that you can use to filter the tables. Selecting a table will show all its columns and types.
[[/si-sketch-v2.png]]

**** Setup and configure Database Container
This is a database application, thus we need a database.  I'll go for MS SQL Server because that is the database I use on my current project.

Fortunately there is a Docker container [[https://hub.docker.com/_/microsoft-mssql-server][here]] from Docker Hub so it will run on linux too. Check the install info at: [[https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash][Docker: Install containers for SQL Server on Linux - SQL Server | Microsoft Docs]].


The following shell script will launch the docker container.

#+begin_src bash
sudo docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=<YourStrong@Passw0rd>" \
   -p 1433:1433 --name sqlserver2019 -h sqlserver2019 \
   -v sql2019data:/var/opt/mssql \
   -d mcr.microsoft.com/mssql/server:2019-latest
#+end_src

Have a look at the parameter /-v/.  This says to create a new volume called /sql2019data/ (if it doesn't already exists). This is actually a container that persists the data and is mounted in the /sqlserver2019/ on the folder /var/opt/mssql/.  If you kill the /sqlserver2019/ container you won't lose the actual data of the database.  This is because the data is not stored in the regular container /sqlserver2019/ but in the container /sql2019data/. See [[https://docs.docker.com/storage/volumes/][Use volumes | Docker Documentation]] and also [[https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-docker-container-configure?view=sql-server-ver15&pivots=cs1-bash#persist][Configure and customize SQL Server Docker containers - SQL Server | Microsoft...]]


Next steps in the database initialization is:
- Create a new database /test_db/.
- Create a new user /test_user/.
- Grant the needed permissions to the /test_user/. To be honest, I only found out what permissions were needed once I started to create the tables in Step 02 here below.
- Change the password for user /sa/.  The original password is forever saved in the environment variable SA_PASSWORD in the containier. Which means it is visible for anyone with access to the container. So it is very important to change the password for /sa/.

For this we will launch the /sqlcmd/ application from within the container :
#+begin_src bash
sudo docker exec -it -w /opt/mssql-tools/bin sqlserver2019 ./sqlcmd -S localhost -U SA
#+end_src

And enter the following commands in the sqlcmd (each command will be executed when you typed 'GO' on a new line):
#+begin_src sql
1> create database test_db
2> go
1> create login test_user with password = 'test123!'
2> go
1> use test_db
2> go
Changed database context to 'test_db'.
1> create user test_user for login test_user
2> go
1> exec sp_addrolemember 'db_datareader', 'test_user'
2> go
1> grant alter on schema::dbo to test_user
2> go
1> grant create table to test_user
2> go
1> grant references to test_user
2> go
1> alter login sa with password = 'NewPassw0rd!'
2> go
1> quit
#+end_src

And finally, when we've finished playing with the container we must stop it. And equally important - because we gave the container a name -  we must also remove the container. If we don't delete,  we won't be able to restart the container the next time.

    #+begin_src bash
    sudo docker stop sqlserver2019
    sudo docker rm sqlserver2019
    #+end_src

**** Practical stuff
You can find the code at https://github.com/pasdut/sqlinspector/.
Every step has its own branch.
If you want to follow along there are a couple of possibilities, depending on your own personal preferences:
**** Clone everything and switch branches on the fly
#+begin_src bash
# clone everything
~$ git clone https://github.com/pasdut/sqlinspector.git
Cloning into 'sqlinspector'...
~$ cd sqlinspector/

# look at the core.clj from step02
~/sqlinspector$ git switch step02
Branch 'step02' set up to track remote branch 'step02' from 'origin'.
Switched to a new branch 'step02'
~/sqlinspector$ cat src/sqlinspector/core.clj
# or you could run step02
~/sqlinspector$ lein run

#switch back to main to see the latest version of core.clj
~/sqlinspector$ git switch main
Switched to branch 'main'
Your branch is up to date with 'origin/main'.
~/sqlinspector$ cat src/sqlinspector/core.clj
#+end_src

**** Clone each step in its own folder
Useful if you want to get all steps in its own folder. You can then open for instance all /core.clj/ files of all different steps at once in your favorite editor.
#+begin_src bash
# get step01 in its own folder
~$ mkdir step01
~$ cd step01
~/step01$ git clone -b step01 https://github.com/pasdut/sqlinspector.git
Cloning into 'sqlinspector'...
~/step01$ cd ..

# get step02 in its own folder
~$ mkdir step02
~$ cd step02
~/step02 git clone -b step02 https://github.com/pasdut/sqlinspector.git
Cloning into 'sqlinspector'...
~/step02$ cd ..

# now the source of both versions are available at the same time
~$ cat ~/step01/sqlinspector/src/sqlinspector/core.clj
~$ cat ~/step02/sqlinspector/src/sqlinspector/core.clj
#+end_src

**** Use the github website
Click on the /branches/ icon to see all branches.
[[file:si-gh-01.png][file:si-gh-01-s.png]]

You can then make a branch active by clicking on it, in the example below click on the /step02/ branch.
[[file:si-gh-02.png][file:si-gh-02-s.png]]

Now you'll see the /step02/ branch is selected.  Click on the commits to see the commits.
[[file:si-gh-03.png][file:si-gh-03-s.png]]

The latest commit is the one that is actually added in this step.  If you click on the commit hash you'll see the diff between previous commits.
[[file:si-gh-04.png][file:si-gh-04-s.png]]

Green is what has been added, red is what has been removed. In the example below you'll notice the single line /:dependencies/ is replaced by a /:dependencies/ that now spans multiple lines.
[[file:si-gh-05.png][file:si-gh-05-s.png]]

**** Step 01 - Create application
Let's create a new application via [[https://leiningen.org/][Leiningen]].  And while we're here, let's also immediately test if the application runs. Just to be sure everything is correctly installed.
#+begin_src
~$ lein new app sqlinspector
~$ cd sqlinspector
~/sqlinspector$ lein run
Hello, World!
#+end_src

**** Step 02 - JDBC Database connection experimentation in the REPL
Data access is via [[https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/][Java JDBC API]]. And on top of JDBC we have the clojure library [[https://github.com/seancorfield/next-jdbc][next-jdbc]].
First of all we must include the dependencies for [[https://github.com/seancorfield/next-jdbc][next.jdbc]] and the [[https://docs.microsoft.com/en-us/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server?view=sql-server-ver15][JDBC driver for MS SQL]].  There is no need to manually download the JDBC driver, /lein/ will take care of that for us.
#+begin_src clojure
  :dependencies [[org.clojure/clojure "1.10.1"]
                 [com.github.seancorfield/next.jdbc "1.2.772"]
                 [com.microsoft.sqlserver/mssql-jdbc "10.2.0.jre11"]]
#+end_src

When we start a REPL these new dependencies will now be retrieved:

#+begin_src
~/sqlinspector$ lein repl
nREPL server started on port 40705 on host 127.0.0.1 - nrepl://127.0.0.1:40705
REPL-y 0.4.4, nREPL 0.7.0
Clojure 1.10.1
OpenJDK 64-Bit Server VM 11.0.11+9-Ubuntu-0ubuntu2.20.10
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

sqlinspector.core=> (quit)
Bye for now!
#+end_src


From now on, I will no longer use the command line to launch a REPL.

Instead I will fully embrace [[https://practical.li/clojure-staging/repl-driven-devlopment.html][REPL driven development]] and enter the expressions directly in my editor (I use emacs + Cider, but you are of course free to use IntelliJ + Cursive or VSCode + Calva)

Let's prepare the /core.clj/ by requiring /next.jdbc/ and adding an empty /comment/ block where we can enter code to be executed immediately.
#+begin_src clojure
(ns sqlinspector.core
  (:gen-class)
  (:require [next.jdbc :as jdbc])
  )

(defn -main
  "I don't do a whole lot ... yet."
  [& args]
  (println "Hello, World!"))

;;----------------------------------------------------------------------------------------
;; Below is a big chunk of . This is used to enter expressions in the REPL directly
;; from within the Editor.
;;----------------------------------------------------------------------------------------
(comment

  ;;type here below all the expressions you want to evaluate in the repl

  )

#+end_src

If we now send the complete file to the repl, the jdbc library will be loaded and we can start using it.

Let's see if we can execute a /select/. Remember, just type the code in the comment section and instruct your editor to send the expression to the REPL.

#+begin_src clojure
;;----------------------------------------------------------------------------------------
;; Below is a big chunk of comment. This is used to enter expressions in the REPL directly
;; from within the Editor.
;;----------------------------------------------------------------------------------------
(comment

  ;; the connection parameters
  (def db {:dbtype "sqlserver"
           :user "test_user"
           :password "test123!"
           :host "127.0.0.1"
           :encrypt false
           :dbname "test_db"})
  (def ds (jdbc/get-datasource db))

  ;; test with the most simple select
  (jdbc/execute! ds ["select 123 as just_a_number"])

  )
#+end_src

Hooray, it works! We just give /jdbc/execute!/ a query and it will be executed.

Let's beef up our database with some tables :

#+begin_src clojure
  (jdbc/execute! ds [(str "create table t_customer ( \n"
                          "  id_customer int not null identity(1,1) \n"
                          "    constraint pk_t_customer primary key, \n"
                          "  first_name varchar(250), \n"
                          "  last_name varchar(250), \n"
                          "  last_modified datetime not null \n"
                          "    constraint df_t_customer default (getdate()))")])

  (jdbc/execute! ds [(str "create table t_address_type ( \n"
                          "  address_type varchar(50) not null \n"
                          "    constraint pk_t_address_type primary key, \n"
                          "  info varchar(250))")])

  (jdbc/execute! ds [(str "create table t_customer_address ( \n"
                          "  id_customer_address int not null identity(1,1) \n"
                          "    constraint pk_t_customer_address primary key, \n"
                          "  id_customer int not null \n"
                          "    constraint fk_t_customer_address__customer \n"
                          "    foreign key references t_customer(id_customer), \n"
                          "  address_type varchar(50) not null \n"
                          "    constraint fk_t_customer_address__addres_type \n"
                          "    foreign key references t_address_type(address_type), \n"
                          "  is_default bit not null \n "
                          "    constraint df_t_customer_address default (0), \n"
                          "  info varchar(250))")])
#+end_src

And now the real work : extract the table names from the database. In Sql Server we find this info in /sys.tables/.

#+begin_src clojure
  (jdbc/execute! ds [(str "select name as table_name, create_date, modify_date \n"
                          "from sys.tables order by name") ])
#+end_src

We can find the columns of a given table in /sys.columns/:

#+begin_src clojure
(let [table-name "t_customer"]
    (jdbc/execute! ds
                   [(str "select \n"
                         "  c.column_id, \n"
                         "  c.name as column_name, \n"
                         "  t.[name] as type_name, \n"
                         "  c.max_length, \n"
                         "  c.is_nullable, \n"
                         "  c.is_identity \n"
                         "from sys.columns c \n"
                         "join sys.types t on t.system_type_id = c.system_type_id \n"
                         "where c.[object_id] = object_id(?) \n"
                         "order by c.column_id")
                    table-name]))
#+end_src

**** Step 03 - Create the database related functions
Let's remove the code from the REPL experiment from /Step 02/ and carve it in stone instead:
- The /(def db ...)/ and /(def ds ...)/ are moved out of the /(comment ...)/ part into the actual source of /core.clj/.
- And two new functions /retrieve-all-tables/ and /retrieve-table-columns/ are created.

Step 03 is just a formality, there is no new code.  This step is just created so you can see on the branch how the code is moved out of the /(comment ...)/ block.

Test in the REPL if the new functions work as expected.
#+begin_src clojure
  ;; check if the new functions work as expected
  (retrieve-all-tables)
  (retrieve-table-columns "t_customer")
#+end_src

**** End of Part 1

This finishes the end of the first Part.  Now we are able to get the needed data from the database. In Part 2 we will start with the UI




*** SQL Inspector : Part 2
:PROPERTIES:
:EXPORT_FILE_NAME: part2
:END:
**** Intro
In part 2 we will develop the user interface.  We will ignore styling and just focus on the mechanics.  The result will be something usable (but with an awful look 'n feel).

I'll also want to demonstrate how the REPL development works step by step. Normally the functions are modified on the fly.  But as an educational tool, I will keep all subsequent versions in the /(comment ... )/ section.

**** Javafx
Now we can start with the actual User interface.

The GUI will be created by [[https://openjfx.io/][JavaFX]]. Go ahead and download and install the binaries [[https://gluonhq.com/products/javafx/][from Gluon]].

Here is a nice [[https://jenkov.com/tutorials/javafx/overview.html][JavaFX Overview]].

On top of JavaFX we will use the clojure wrapper [[https://github.com/cljfx/cljfx][cljfx]].

**** Step 04 - Let's show something
***** 4.1 Add cljfx dependency
First add cljfx to the dependencies in /project.clj/.
#+begin_src clojure
;; project.clj
:dependencies [[org.clojure/clojure "1.10.1"]
               [com.github.seancorfield/next.jdbc "1.2.772"]
               [com.microsoft.sqlserver/mssql-jdbc "10.2.0.jre11"]
               [cljfx "1.7.16"]
               ]

#+end_src


We can't use cljfx if we don't /require/ it. Thus add it in core.clj too.

#+begin_src clojure
;;core.clj
(ns sqlinspector.core
  (:gen-class)
  (:require [next.jdbc :as jdbc]
            [cljfx.api :as fx])
  )
#+end_src

Now instruct /lein/ to load the dependencies. And to see if everything works as it should we start de REPL from /lein/ too.
#+begin_src bash
~/sqlinspector$ lein deps
~/sqlinspector$ lein repl
Error in glXCreateNewContext, remote GLX is likely disabled
nREPL server started on port 37031 on host 127.0.0.1 - nrepl://127.0.0.1:37031
REPL-y 0.4.4, nREPL 0.7.0
Clojure 1.10.1
OpenJDK 64-Bit Server VM 11.0.11+9-Ubuntu-0ubuntu2.20.10
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

sqlinspector.core=> (quit)
Bye for now!
#+end_src

(There is an /Error in glxCreateNewContext/ but I guess it might be because I'm running in WSL on Windows, so just ignore it...)

If you have a REPL open in your editor, don't forget to reload that REPL too.

***** 4.2 Hello there
To get our feet wet we start with the [[https://github.com/cljfx/cljfx#hello-world][cljfx Hello World]] example.
#+begin_src clojure
(fx/on-fx-thread
   (fx/create-component
    {:fx/type :stage
     :showing true
     :title "Cljfx example"
     :width 300
     :height 100
     :scene {:fx/type :scene
             :root {:fx/type :v-box
                    :alignment :center
                    :children [{:fx/type :label
                                :text "Hello from SQL Inspector"}]}}}))
#+end_src

If all went well you should get the following window:
[[file:si-step04-01.png]]

***** 4.3 Let's program interactively
We want to develop the GUI interactively from within the REPL. The following is heavily based on the example [[https://github.com/cljfx/cljfx/blob/master/examples/e12_interactive_development.clj][e12_interactive_development.clj]] from the cljfx [[https://github.com/cljfx/cljfx/tree/master/examples][examples]].

The idea is whenever you changed a function, just call /(renderer)/ to redisplay the GUI.

You are supposed to execute the code that follows expression by expression, without the need to reload or recompile the complete application. Power to the REPL...

Let's see if we can display a label and a text-box.
#+begin_src clojure
  ;; A state with some dummy data that we will display
  (def *state
    (atom {:table-filter "some filter data"}))


  (defn root-view [{{:keys [table-filter]} :state}]
    {:fx/type :stage
     :showing true
     :title "SQL inspector"
     :width 500
     :height 300
     :scene {:fx/type :scene
             :root {:fx/type :v-box
                    :children [{:fx/type :label
                                :text "Table filter:"}
                               {:fx/type :text-field
                                :text table-filter}]}}})

  (def renderer
    (fx/create-renderer
     :middleware (fx/wrap-map-desc (fn [state]
                                     {:fx/type root-view
                                      :state state}))))

  ;; Start watching for state changes and call the renderer.
  ;; This will show the window.
  (fx/mount-renderer *state renderer)

  ;; Whenever we update the state, the text-field should update too.
  (reset! *state {:table-filter "filter changed"})
#+end_src

Did you noticed the text-field showed the new value after you updated the state?

This is the resulting window:
[[file:si-step04-3-20.png]]

***** 4.4 Get to the bones
Now we are ready to build the skeleton of our application.

My motto is to let the user be as much as possible in control over the layout. Thus we immediately add a splitter with the [[https://jenkov.com/tutorials/javafx/splitpane.html][JavaFX SplitPane]], to let him decide how big he wants the tables part versus the columns part.

Here is a schema of what we will build in this step :
[[file:si-step04-04-10.png]]

#+begin_src clojure
  ;; The skeleton of the application
  (defn root-view [{{:keys [table-filter selected-table]} :state}]
    {:fx/type :stage
     :showing true
     :title "SQL inspector"
     :width 500
     :height 300
     :scene {:fx/type :scene
             :root {:fx/type :v-box
                    :children [{:fx/type :split-pane
                                :items [{:fx/type :v-box
                                         :children [{:fx/type :label
                                                     :text "Table filter:"}
                                                    {:fx/type :text-field
                                                     :text table-filter}
                                                    {:fx/type :label
                                                     :text "Tables:"}]}
                                        {:fx/type :v-box
                                         :children [{:fx/type :label
                                                     :text (str "Columns for table:"
                                                                selected-table)}]}]}]}}})
  ;; We updated the view, thus must re-render.
  (renderer)

  ;; The new root-view expects the key :selected-table in the state,
  ;; so add it to the state.
  ;; Because we renderer is watching *state (see step 4.3) the screen
  ;; is immediately updated.
  (reset! *state {:table-filter "some filter data xx"
                  :selected-table "t_my_table"})
#+end_src

And this is the window so far:

[[file:si-step04-04-20.png]]

You might have noticed the splitter doesn't fill the complete window. Don't worry. For now, we are just working on the mechanics, not on the visuals.

***** 4.5 Code cleanup
If you take a look at the /root-view/ function, there is a lot of nesting going on.  And I foresee this will gain some more complexity.

Therefore I decided to refactor this a little bit.  Let's move the rendering of the tables — the left side of the split-pane — and the rendering of the columns — the right side of the split-pane — in their own functions.

#+begin_src clojure
  ;; Move tables and columns in their own function
  (defn tables-view [{:keys [table-filter]}]
    {:fx/type :v-box
     :children [{:fx/type :label
                 :text "Table filter:"}
                {:fx/type :text-field
                 :text table-filter}
                {:fx/type :label
                 :text "Tables:"}]})

  (defn columns-view [{:keys [selected-table]}]
    {:fx/type :v-box
     :children [{:fx/type :label
                 :text (str "Columns for table: " selected-table)}]})

  (defn root-view [{{:keys [table-filter selected-table]} :state}]
    {:fx/type :stage
     :showing true
     :title "SQL inspector"
     :width 500
     :height 300
     :scene {:fx/type :scene
             :root {:fx/type :v-box
                    :children [{:fx/type :split-pane
                                :items [{:fx/type tables-view
                                         :table-filter table-filter }
                                        {:fx/type columns-view
                                         :selected-table selected-table }]}]}}})
  ;; We updated the view, thus must re-render.
  (renderer)

#+end_src

**** Step 05 - Run something
In the previous step 04, we've tried in the REPL to build our first version of the GUI.  In this step we'll use the stuff we learned.  Now we will update our application in such a way that /lein run/ will actually show our basic window.

First of all we'll delete the functions /tables-view, columns-view, root-view/ and /renderer/ from the /(comment ...)/ block and create them into the source code above the /(comment ...)/.

Second, we create a new function /initialize-cljfx/ to mount the state and the renderer.

And finally the  /-main/ is changed to call the initialization function. We can then run the application on the commandline via /lein run/. Or we could launch the application via the REPL by evaluating /(-main)/

#+begin_src clojure
(defn initialize-cljfx []
  (fx/mount-renderer *state renderer))

(defn -main
  [& args]
  (initialize-cljfx))

(comment

  ;; run the application from the REPL
  (-main)
)
#+end_src

This is the last time you can see the different steps that I executed in the Repl. You can see these in the /(comment ...)/ block in Step 04.

Now, please forgive me, but keeping this backlog of code I executed in the REPL involves a lot of copy paste work from my part. Besides, I assume you now get the idea how REPL development actually works. And thus, for all subsequent steps, I'll only commit the final code.

**** Step 06 - Handle something
Up to our first event handler.

The goal for this step is to update the field /:table-filter/ in the /*state/ whenever the user enters text in the text field.

Remember from the previous steps that cljfx is monitoring the state. And when something from the state has changed cljfx will update the window. To see this in action we'll temporary add a label to the /tables-view/ that shows the contents of the /*state/  /:table-filter/.

#+begin_src clojure
;; change this immediately in the code and evaluate that in the REPL
(defn tables-view [{:keys [table-filter]}]
  {:fx/type :v-box
   :children [{:fx/type :label
               :text "Table filter:"}
              {:fx/type :text-field
               :text table-filter}
              {:fx/type :label
               :text "Tables:"}
              ;; temporary added
              {:fx/type :label
               :text (str ":table-filter contains " table-filter)}]})
#+end_src

And as we already know, after changing a view function we must call /renderer/.
#+begin_src clojure
  ;; Whenever we changed the user interface we must rerender
  ;; This is something we will often do, so keep this in the comment
  (renderer)
#+end_src
[[file:si-step06-10.png]]

/*state/ is an atom, so we can give it a new value. Let's update :table-filter and see if cljfx picks it up.

#+begin_src clojure
  (swap! *state assoc :table-filter "Blah blah")
#+end_src
Did you notice — after you evaluated the previous expression — that both the textbox and the label were updated and they both show /Blah blah/?

Of course we won't manually update the state when we want to use another filter.  Instead we'll use the  /on-text-changed/ handler of the text field to update the filter. In /cljfx/ we just need to add the keyword /:on-text-changed/ with as value a (anonymous) function.

#+begin_src clojure
(defn tables-view [{:keys [table-filter]}]
  {:fx/type :v-box
   :children [{:fx/type :label
               :text "Table filter:"}
              {:fx/type :text-field
               :text table-filter
               ;; handler
               :on-text-changed #(swap! *state assoc :table-filter %)}
              {:fx/type :label
               :text "Tables:"}
              ;; temporary added
              {:fx/type :label
               :text (str ":table-filter contains " table-filter)}]})
#+end_src

Now we are getting somewhere.  When you enter text in the textbox, the /:table-filter/ of the /*state/ gets updated.  Which in turn resulted in an update of the label.

There is however a problem. The view function /tables-view/ now has to know the structure of /*state/. In other words, the view function is coupled to the state.

Fortunately, cljfx let us also define an event handler as an arbitrary map. See the next step...

**** Step 07 - Pure events in the view
Let's use a map for the :on-text-changed event:
#+begin_src clojure
(defn tables-view [{:keys [table-filter]}]
  {:fx/type :v-box
   :children [{:fx/type :label
               :text "Table filter:"}
              {:fx/type :text-field
               :text table-filter
               ;; use a map
               :on-text-changed {:event/type :update-table-filter}}
              {:fx/type :label
               :text "Tables:"}
              {:fx/type :label
               :text (str ":table-filter contains " table-filter)}]})
#+end_src

The /tables-view/ function is now again a pure function without side effects.

These kind of events are handled asynchronous by /cljfx/.  We also need to provide a function to the renderer so it knows how to actually handles these map-events.

#+begin_src clojure
(defn map-event-handler [event]
  ;; just print the event we get
  (println "Event Received : " event ))
#+end_src

And we must tell the renderer to use our mapping function:
#+begin_src clojure
(def renderer
  (fx/create-renderer
   :middleware (fx/wrap-map-desc (fn [state]
                                   {:fx/type root-view
                                    :state state}))
   :opts {:fx.opt/map-event-handler map-event-handler}))
#+end_src

To see these changes, you need to execute /(-main)/ in the REPL.  If this doesn't work then try to refresh the REPL and then execute /(-main)/ followed by  /(renderer)/. If you had an existing /Sql Inspector/ window open, then first close it before calling the /(renderer)/

If everything went well, and you typed /abc/ in the text edit you will see the following output:
#+begin_src clojure
Event Received :  {:event/type :update-table-filter, :fx/event a}
Event Received :  {:event/type :update-table-filter, :fx/event ab}
Event Received :  {:event/type :update-table-filter, :fx/event abc}
#+end_src

We found out the structure of the /event/ parameter we receive in /map-event-handler/.  Now use it.

I found out it is hard to get this reloaded in the REPL.  So I changed also the /println/ from outputting /"Event Received"/ to just /"Event:"/.  So we can see in the output that the latest handler is loaded.

#+begin_src clojure
(defn map-event-handler [event]
  (println "Event : " event )
  (case (:event/type event)
    :update-table-filter  (swap! *state assoc :table-filter (:fx/event event))))
#+end_src

So just like before, close all open /Sql Inspector/ windows, re-evaluate /(-main)/ and /(renderer)/. And maybe restart the complete REPL when needed.

The end result now is the label is automatically updated whenever you type something in the filter text edit.

To recap how this event handling works :
 - The user types a character in the text edit.
 - That character is immediately shown in the text edit because of the OS Widget implementation.
 - That widget generates an event /:on-text-changed/.
 - We defined that the /:on-text-changed/ event should generate a /cljfx/ event  /:update-table-filter/.
 - /cljfx/ will then handle that event asynchronously by calling our /map-event-handler/ function.
 - That function will then finally update the  /:table-filter/ value of our /*state/.
 - Which in turn will then update the /:text/ of both the text-edit and the temporary label.

There is one issue with this in the rare case when the user types extremely fast. I mean, when he types sooooo fast that /cljfx/ events are piled up.

Imagine the user types /"abc"/ really fast.  And /cljfx/ only starts to process the /:update-table-filter/ event for the /"a"/ after the user finished typing the /"abc"/.

What will happen is that the text edit first will contain /"abc"/ because the OS Widget shows immediately what he types.  And then a moment later this is changed to /"a"/ because of the processing of the /:update-table-filter/ event. In the best case the user will experience some lagging, in the worst case he will miss some characters. (/cljfx/ got some ideas from /re-frame/ and here is the same issue explained : [[https://day8.github.io/re-frame/FAQs/laggy-input/][Why is my input field laggy?]])

Fortunately the solution is simple: inform /cljfx/ to handle this event synchronously.  Just notice this is only needed for text inputs.
#+begin_src clojure
(defn tables-view [{:keys [table-filter]}]
  {:fx/type :v-box
   :children [{:fx/type :label
               :text "Table filter:"}
              {:fx/type :text-field
               :text table-filter
               :on-text-changed {:event/type :update-table-filter
                                 ;; handle this synchronously
                                 :fx/sync true}}
              {:fx/type :label
               :text "Tables:"}
              {:fx/type :label
               :text (str ":table-filter contains " table-filter)}]})
#+end_src
**** Step 08 - Pure event handlers
The event handler /map-event-handler/ that processes the event /:update-table-filter/ is still coupled to (and updates) the /*state/ atom. This makes testing hard because we must mock the state in our tests.

It would be handy if the event handler could be just data in, data out. See the cljfx documentation [[https://github.com/cljfx/cljfx#event-handling-on-steroids][Event handling on steroids]].

We have 2 things to do.

First we need to get the /state/ as input to the event handler. The /cljfx/ function /wrap-co-effects/ does this for us and will pass the dereferenced /state/ to our handler.  The state will be inserted in the /event/ map.

#+begin_src clojure
(defn event-handler [event]
  (println "event-handler:" event))

;; Notice this is "def" and not "defn" as wrap-co-effects
;; returns a function.
(def map-event-handler
    (-> event-handler
        (fx/wrap-co-effects
         {:state (fx/make-deref-co-effect *state)})
        ))
#+end_src

This is again a modification of the cljfx initialization stuff. If you're still in the REPL then first close existing SQL Inspector windows. Then evaluate the complete source and execute /(-main)/.

If we now type /"abc"/ in the search filter we get the following output:
#+begin_src shell
event-handler: {:event/type :update-table-filter, :fx/sync true, :fx/event a, :state {:table-filter , :selected-table }}
event-handler: {:event/type :update-table-filter, :fx/sync true, :fx/event ab, :state {:table-filter , :selected-table }}
event-handler: {:event/type :update-table-filter, :fx/sync true, :fx/event abc, :state {:table-filter , :selected-table }}
#+end_src
Notice we now have a key /:state/, so we no longer have to dereference the actual state.  It is just data /in/.

Next step is to return the updated state.
#+begin_src clojure
(defn event-handler [e]
  (println "event-handler:" e)
  (let [{:keys [event/type fx/event state]} e]
    (case type
      :update-table-filter {:state (assoc state :table-filter event)})))
#+end_src

This is the data /out/. And it is easy to verify if the state (not the real state, but the :state in the returning map) is updated as expected.
#+begin_src clojure
(event-handler
 {:event/type :update-table-filter
  :fx/event "xyz"
  :state {:table-filter "abc"}})
=>{:state {:table-filter "xyz"}}
#+end_src

The last thing we have to do now is to use the value returned from the event to update the actual /State/ atom.  For this we use /wrap-effects/.

#+begin_src clojure
;; Notice this is "def" and not "defn" as wrap-co-effects and wrap-effects
;; return a function.
(def map-event-handler
    (-> event-handler
        (fx/wrap-co-effects
         {:state (fx/make-deref-co-effect *state)})
        (fx/wrap-effects
         {:state (fn [state _] (reset! *state state))})))
#+end_src

When we now type something in the text box, the actual state will be updated.  And this causes the label to show what we have typed.
**** End of Part 2
This concludes the second part in the series.

We created a basic window, learned and discovered how we can react to events.  With these building blocks in our toolbox we can go on building our application.
Part 3, here we come...


*** SQL Inspector : Part 3
:PROPERTIES:
:EXPORT_FILE_NAME: part3
:END:

**** Step 09 - Show the tables
Now it is time to visualize the tables.

For this we extend the state with a new key /:tables/.  And we update /(-main)/ to actually retrieve the tables.

#+begin_src clojure
(def *state
  (atom {:table-filter ""
         :selected-table ""
         :tables []}))

(defn -main
  [& args]
  (swap! *state assoc :tables (retrieve-all-tables))
  (initialize-cljfx))
#+end_src

Do not forget to re-execute /(-main)/ to be sure the tables are actually loaded in /state/ for your current REPL. And in some cases you must completely reload the file too. This is because the event /:update-table-filter/ messes with the state and the /:tables/ are lost if you don't reload the full file after modifying the /state/.


Just to be sure, let's check whether the /state/ now contains the tables:

#+begin_src clojure
sqlinspector.core> *state
;; => #<Atom@1e3168e8:
  {:table-filter "",
   :selected-table "",
   :tables
   [{:table_name "t_address_type",
     :create_date #inst "2022-03-25T21:02:17.320000000-00:00",
     :modify_date #inst "2022-03-25T21:16:14.677000000-00:00"}
    {:table_name "t_customer",
     :create_date #inst "2022-03-25T21:02:13.880000000-00:00",
     :modify_date #inst "2022-03-25T21:16:14.677000000-00:00"}
    {:table_name "t_customer_address",
     :create_date #inst "2022-03-25T21:16:14.677000000-00:00",
     :modify_date #inst "2022-03-25T21:16:14.677000000-00:00"}]}>
#+end_src

(Remark: I also fixed a typo in /retrieve-all-tables/.  The field /modify_date/ was incorrectly aliased to /table_name/)


Let's display a /table view/ that contains the table names.

We could have used a /list view/ because we only have one column.  However we might add additional columns in the future like creation date or number of records in the table. Therefore we'll stick with /table view/.

In the cljfx [[https://github.com/cljfx/cljfx/tree/master/examples][examples]] folder, the example [[https://github.com/cljfx/cljfx/blob/master/examples/e27_selection_models.clj][e27_selection_models]] teaches us how we can display a /table view/.

We need an event to know when the selection is changed. That's why we use /cljfx.ext.list-view/with-selection-props/, just like in the example.

First of all, we must add a new /require/:

#+begin_src clojure
(ns sqlinspector.core
  (:gen-class)
  (:require [next.jdbc :as jdbc]
            [cljfx.api :as fx]
            [cljfx.ext.table-view :as fx.ext.table-view])
  )
#+end_src

Next, we update the /tables-view/ function to actually create the table-view. It is yet unclear to me what data I get.  Therefore I add a /println/ and return some dummy text.


#+begin_src clojure
(defn tables-view [{:keys [table-filter tables]}]
  {:fx/type :v-box
   :children [{:fx/type :label
               :text "Table filter:"}
              {:fx/type :text-field
               :text table-filter
               ;; use a map
               :on-text-changed {:event/type :update-table-filter
                                 :fx/sync true}}
              {:fx/type :label
               :text "Tables:"}
              ;; temporary added
              {:fx/type :label
               :text (str ":table-filter contains " table-filter)}
              {:fx/type fx.ext.table-view/with-selection-props
               :props {:selection-mode :single}
               :desc {:fx/type :table-view
                      :columns [{:fx/type :table-column
                                 :text "Tablename"
                                 :cell-value-factory identity
                                 :cell-factory {:fx/cell-type :table-cell
                                                :describe (fn [x]
                                                            (println "Data for the cell Tablename is:" x)
                                                            {:text "DUMMY TEXT"})}}]
                      :items tables }}]})
#+end_src

We now have an extra parameter /tables/, se we must pass that from the /root-view/ to /tables-view/:

#+begin_src clojure
(defn root-view [{{:keys [table-filter selected-table tables]} :state}]
  {:fx/type :stage
   :showing true
   :title "SQL inspector"
   :width 500
   :height 300
   :scene {:fx/type :scene
           :root {:fx/type :v-box
                  :children [{:fx/type :split-pane
                              :items [{:fx/type tables-view
                                       :table-filter table-filter
                                       :tables tables}
                                      {:fx/type columns-view
                                       :selected-table selected-table}]}]}}})
#+end_src

After calling /(renderer)/ we see the result of the /print/ statements:

#+begin_src clojure
Data for the cell Tablename is: {:table_name t_address_type, :create_date #inst "2022-03-25T21:02:17.320000000-00:00", :modify_date #inst "2022-03-25T21:16:14.677000000-00:00"}
Data for the cell Tablename is: {:table_name t_customer, :create_date #inst "2022-03-25T21:02:13.880000000-00:00", :modify_date #inst "2022-03-25T21:16:14.677000000-00:00"}
Data for the cell Tablename is: {:table_name t_customer_address, :create_date #inst "2022-03-25T21:16:14.677000000-00:00", :modify_date #inst "2022-03-25T21:16:14.677000000-00:00"}
#+end_src

It seems we get the table data as parameter to the /describe/ function of the /cell-factory/. Let's change parameter /x/ to something meaningful, like /table-data/. For now we just visualize the /:table_name/. And lets comment out the /println/ statement:
#+begin_src clojure
:cell-factory {:fx/cell-type :table-cell
               :describe (fn [table-data]
                           #_(println "Data for the cell Tablename is:" table-data)
                           {:text (:table_name table-data) })}
#+end_src

After /(renderer)/ we get the following result:

[[file:si-step09-10.png]]

**** Step 10 - Context

For now, the tables in the list are not yet filtered.

However, before we fix this, let's first introduce the concept of /context/.  See explanation in the official cljfx documentation : [[https://github.com/cljfx/cljfx#subscriptions-and-contexts][Subscriptions and Context]].

The idea is that the views shouldn't know the full structure of the state. Instead a view should subscribe to a piece of data. Additionally, values can be cached so a view will only render when the actual value it depends on is changed. An example: the user keeps adding characters to the filter. If the list of filtered tables doesn't change after updating the filter text, the view won't be rendered again.
***** 10.1 Add /core.cache/
Whenever we use /cljfx contexts/ we must add the /core.cache/ dependency.

Update /project.clj/
#+begin_src clojure
;; project.clj
:dependencies [[org.clojure/clojure "1.10.1"]
                 [com.github.seancorfield/next.jdbc "1.2.772"]
                 [com.microsoft.sqlserver/mssql-jdbc "10.2.0.jre11"]
                 [cljfx "1.7.16"]
                 [org.clojure/core.cache "0.7.1"]  ;;--- ADDED ---
                 ]
#+end_src

Add to /:require/ in /core.clj/:
#+begin_src clojure
;; core.clj
(ns sqlinspector.core
  (:gen-class)
  (:require [next.jdbc :as jdbc]
            [cljfx.api :as fx]
            [cljfx.ext.table-view :as fx.ext.table-view]
            [clojure.core.cache :as cache])  ;;--- ADDED ---
  )
#+end_src

Don't forget to restart your REPL to load the new module and then also reload the complete /core.clj/ file in your REPL.
***** 10.2 Start using Context
Update the source to use /context/.

First of all, the /state/ is now a /context/:
#+begin_src clojure
(def *state
  (atom (fx/create-context  ;;--- ADDED ---
         {:table-filter ""
          :selected-table ""
          :tables []}
         cache/lru-cache-factory)))  ;;--- ADDED ---
#+end_src

Add some middle ware to pass the /context/ through the /option/ map.

#+begin_src clojure
(def renderer
  (fx/create-renderer
   :middleware (comp ;;--- ADDED --- middleware is now a composition of multiple functions
                ;; Pass context to every lifecycle as part of option map
                fx/wrap-context-desc ;;--- ADDED ---
                (fx/wrap-map-desc (fn [_]{:fx/type root-view})))
   :opts {:fx.opt/map-event-handler map-event-handler
          :fx.opt/type->lifecycle #(or (fx/keyword->lifecycle %);;--- ADDED ---
                                       ;; For functions in ':fx/type' values, pass
                                       ;; context from option map to these functions
                                       (fx/fn->lifecycle-with-context %))}));;--- ADDED ---
#+end_src

The /root-view/ no longer needs to pass data to /tables-view/ and /columns-view/. Heck, /root-view/ can just ignore its own parameters

#+begin_src clojure
(defn root-view [_] ;;--- IGNORE PARAMETER ---
  {:fx/type :stage
   :showing true
   :title "SQL inspector"
   :width 500
   :height 300
   :scene {:fx/type :scene
           :root {:fx/type :v-box
                  :children [{:fx/type :split-pane
                              :items [{:fx/type tables-view} ;;--- NO MORE PARAMETER PASSING ---
                                      {:fx/type columns-view}]}]}}});;--- NO MORE PARAMETER PASSING ---
#+end_src


The function /columns-view/ no longer receives the /selected-table/ as parameter. Instead a context is received.  The  /columns-view/ should now extract the /selected-table/ value from the /context/ via the /fx/sub-val/ function.
#+begin_src clojure
(defn columns-view [{:keys [fx/context]}] ;;--- PARAMETER NOW CONTAINS CONTEXT ---
  {:fx/type :v-box
   :children [{:fx/type :label
               :text (str
                      "Columns for table: "
                      (fx/sub-val context :selected-table))}]}) ;;--- USE "sub-val" ---
#+end_src

The /tables-view/ function must also be converted to using context.

#+begin_src clojure
(defn tables-view [{:keys [fx/context]}];;--- PARAMETER NOW CONTAINS CONTEXT ---
  {:fx/type :v-box
   :children [{:fx/type :label
               :text "Table filter:"}
              {:fx/type :text-field
               :text (fx/sub-val context :table-filter);;--- USE "sub-val" ---
               ;; use a map
               :on-text-changed {:event/type :update-table-filter
                                 :fx/sync true}}
              {:fx/type :label
               :text "Tables:"}
              ;; temporary added
              {:fx/type :label
               :text (str
                      ":table-filter contains "
                      (fx/sub-val context :table-filter))};;--- USE "sub-val" ---
              {:fx/type fx.ext.table-view/with-selection-props
               :props {:selection-mode :single}
               :desc {:fx/type :table-view
                      :columns [{:fx/type :table-column
                                 :text "Tablename"
                                 :cell-value-factory identity
                                 :cell-factory
                                 {:fx/cell-type :table-cell
                                  :describe (fn [table-data]
                                              #_(println "Data for the cell Tablename is:" table-data)
                                              {:text (:table_name table-data) })}}]
                      :items (fx/sub-val context :tables)}}]});;--- USE "sub-val" ---
#+end_src

The function /(-main)/ loads all the table names in the /state/.  This /state/ is now a /context/ so we must use /fx/swap-context/ to load all tables.
#+begin_src clojure
(defn -main
  [& args]
  (reset! *state (fx/swap-context @*state assoc :tables (retrieve-all-tables)))
  (initialize-cljfx))
#+end_src

At this point of the refactoring to use /context/ we can already execute /(-main)/ and see if the changes work. Normally you should see all table names, the same as the screenshot from the previous step 09.

Remember, we didn't update the event handling yet. So you'll probably get an error as soon as you type something in the text field!

Let's manually set the filter with /fx/swap-context/ and see if this works...
#+begin_src clojure
(reset! *state (fx/swap-context @*state assoc :table-filter "Blah blah"))
#+end_src

Executing the previous line in the REPL should update the search filter in the application.

The /event-handler/ function should also update the context via /swap-context/
#+begin_src clojure
(defn event-handler [e]
  (println "event-handler:" e)
  (let [{:keys [event/type fx/event fx/context]} e] ;;--- use fx/context ---
    (case type
      :update-table-filter {:context (fx/swap-context context assoc :table-filter event)})));;--- USE "swap-context" ---
#+end_src

Now we need to pass the context to the event handler as a co-effect.
And, based on [[https://github.com/cljfx/cljfx/blob/master/examples/e18_pure_event_handling.clj][examples/e18_pure_event_handling.clj]], we also define 2 effects /:context/ and /:dispatch/. If these keys are returned by the event handler, the corresponding effect will be executed. See also : [[https://github.com/cljfx/cljfx#event-handling-on-steroids][cljfx doc : Event handling on steroids]]
#+begin_src clojure
(def map-event-handler
    (-> event-handler
        (fx/wrap-co-effects
         ;;--- Pass the deref state as :fx/context to the event-handler  ---
         {:fx/context (fx/make-deref-co-effect *state)})
        (fx/wrap-effects
         ;;--- what to do if event handler returns :context or :dispatch---
         {:context (fx/make-reset-effect *state)
          :dispatch fx/dispatch-effect})))
#+end_src

Remark that we changed the event-handler, which is a crucial part of the application.  These changes are not easily picked up by the REPL.  It is important to close the running REPL, restart it and reload the source.  Then you can execute the /(-main)/ function to start the application.

The end result is we simplified the parameters to the view functions by passing only the /context/.  With the additional bonus that the values are cached and a view is only regenerated when the value is actually changed.

**** Step 11 - Apply filtering

Now we can begin to filter the tables list.

We could do the filtering directly in /tables-view/. However, I'd rather keep data manipulation out of the view logic.

Let's try if we get the filtering to work, without using cljfx specifics. We opt for a case insensitive search. As a matter of test we try to get all tables that matches the search text /"CUST"/. Execute the following in the REPL to see if we get the expected result.
#+begin_src clojure
(let [tables (retrieve-all-tables)
        table-filter "CUST"
        table-filter-pattern (re-pattern (str "(?i).*" table-filter ".*"))]
    (filter #(re-matches table-filter-pattern (:table_name %)) tables))
;; => ({:table_name "t_customer",
;; =>   :create_date #inst "2022-03-25T21:02:13.880000000-00:00",
;; =>   :modify_date #inst "2022-03-25T21:16:14.677000000-00:00"}
;; =>  {:table_name "t_customer_address",
;; =>   :create_date #inst "2022-03-25T21:16:14.677000000-00:00",
;; =>   :modify_date #inst "2022-03-25T21:16:14.677000000-00:00"})
#+end_src
It seems to be working.

Now we can create a subscription function. (See explanation in the official cljfx documentation : [[https://github.com/cljfx/cljfx#subscriptions-and-contexts][Subscriptions and Context]])
#+begin_src clojure
(defn subs-filtered-tables
  "Returns all tables that satisfy to the search text."
  [context]
  (let [tables (fx/sub-val context :tables)
        table-filter (fx/sub-val context :table-filter)
        table-filter-pattern (re-pattern (str "(?i).*" table-filter ".*"))]
    (filter #(re-matches table-filter-pattern (:table_name %)) tables)))
#+end_src

Rest us to modify the /tables-view/ function to use that subscription via /fx/sub-ctx/
#+begin_src clojure
(defn tables-view [{:keys [fx/context]}]
  {:fx/type :v-box
   :children [;; ...
              {:fx/type fx.ext.table-view/with-selection-props
               :props {:selection-mode :single}
               :desc {:fx/type :table-view
                      :columns [
                                 ;; ...
                                ]
                      :items (fx/sub-ctx context subs-filtered-tables)}}]}) ;;--- USE SUBSCRIPTION ---
#+end_src

If you now evaluate /(renderer)/ in the REPL you'll see the filtering is now working.
**** Step 12 - Table selection
***** 12.1 Select a table from the list
Before we can show the columns, we must know what table is clicked on. We can do this by responding to the /:on-selected-item-changed/ event. Let's fire the event /:select-table/ as a responce.
#+begin_src clojure
(defn tables-view [{:keys [fx/context]}]
  {:fx/type :v-box
   :children [;; ...
              {:fx/type fx.ext.table-view/with-selection-props
               :props {:selection-mode :single
                       :on-selected-item-changed {:event/type :select-table}} ;; NEW EVENT
               ;; ...
               }]})
#+end_src

And handle that event appropriately.
#+begin_src clojure
(defn event-handler [e]
  (println "event-handler:" e)
  (let [{:keys [event/type fx/event state]} e]
    (case type
      :update-table-filter {:state (fx/swap-context state assoc :table-filter event)}
      ;; NEW EVENT
      :select-table {:state (fx/swap-context state assoc :selected-table (:table_name event))})))
#+end_src

Because we updated the event-handler we must unfortunately quit and restart the REPL to have it in effect.
But once the app is up and running again, whenever we select a table that table name appears on the  columns header.
[[file:si-step12-10.png]]

***** 12.2 Multi method event handling

The function /event-handler/ is on its way to become a huge monster /case/ statement. (Yes I hear you, 2 clauses is not really too big, I know)

Let's refactor it via a multi methods.

#+begin_src clojure
(defmulti event-handler :event/type)

(defmethod event-handler :default [event]
  (println "Unhandled event")
  (prn event)
  )

(defmethod event-handler :update-table-filter [{:keys [state fx/event]}]
  (println ":update-table-filter --->" event)
  {:state (fx/swap-context state assoc :table-filter event)})

(defmethod event-handler :select-table [{:keys [state fx/event]}]
  (let [table-name (:table_name event)]
    (println ":select-table --> " table-name)
    {:state (fx/swap-context state assoc :selected-table table-name)}))
#+end_src

Once again, we must restart the REPL and reload the source.  However it is the last time we need a full restart of the REPL. For some reason, updating a branch on a multimethod gets immediately picked up by the REPL. You can see this if you change the text in the /println/, re-evaluate that /defmethod/, and bam, it has effect.

***** 12.3 Auto table selection
It would be nice if the first table of the list will be selected automatically whenever the filter is changed.

Say we have an empty filter and we clicked the first table to select it. On the right side we see /Columns for table: t_address_type/.
[[file:si-step12-30.png]]

If we now type /"cus"/ in the /table filter/, the table /t_address_type/ disappears from the table view. However the current selected table (see green) still remains /t_address_type/.

[[file:si-step12-31.png]]

What we actually want is to select automatically the first table whenever the table list is changed.

Adhering to the single responsibility principle we create a new event /select-visible-table/. That event will be fired by the /update-table-filter/. This is achieved because we return the key /:dispatch/.

#+begin_src clojure
;;--- NEW EVENT ---
(defmethod event-handler :select-visible-table [{:keys [fx/context fx/event]}]
  (println ":select-visible-table "))

(defmethod event-handler :update-table-filter [{:keys [fx/context fx/event]}]
  (println ":update-table-filter --->" event)
  {:context (fx/swap-context context assoc :table-filter event)
   :dispatch {:event/type :select-visible-table}}) ;;--- EMIT THE NEW EVENT ---
#+end_src

If we now change the table filter (by typing in the textbox), the text /":select-visible-table"/ is printed on the output.

The next step is to create a subscription function that actually returns the first table.
#+begin_src clojure
(defn subs-visible-table-to-select
  "Return the table from the visible table list that must be selected"
  [context]
  (let [tables (fx/sub-ctx context subs-filtered-tables)]
    (first tables)))
#+end_src

When the filter is empty, the first table should be /t_address_type/. Let's check this by executing the following code in the repl:

#+begin_src clojure
  (reset! *state (fx/swap-context @*state assoc :table-filter ""))
  (println (fx/sub-ctx @*state subs-visible-table-to-select))
  ;;==> {:table_name t_address_type, :create_date ...}
#+end_src

And when the filter is /cus/, the first table should be /t_customer/:

#+begin_src clojure
  (reset! *state (fx/swap-context @*state assoc :table-filter "cus"))
  (println (fx/sub-ctx @*state subs-visible-table-to-select))
  ;;==> {:table_name t_customer, :create_date ...}
#+end_src

Woo-hoo, it works!  Let's incorporate this in the /select-visible-table/ event.

#+begin_src clojure
(defmethod event-handler :select-visible-table [{:keys [fx/context fx/event]}]
  (let [table-name (:table_name (fx/sub-ctx context subs-visible-table-to-select))]
    (println ":select-visible-table --> table = " table-name)
    {:context (fx/swap-context context assoc :selected-table table-name)}))
#+end_src

If we now play with the table-filter the first table is selected in the state. This means whatever filter you type, the right side /Columns for table: xxx/ always shows the first table of the visible tables.

***** 12.4 Show the selected table
We have a slightly cosmetic problem.  If we use the filter /cus/ the first matching table is selected.  In this case it is /t_customer/, which is visible in the header on the right. However, this is not visible in the table view on the left.

[[file:si-step12-40.png]]

From the example [[https://github.com/cljfx/cljfx/blob/master/examples/e27_selection_models.clj][examples/e27_selection_models.clj]] it seems we should set the property /:selected-item/. The documentation in [[https://github.com/cljfx/cljfx/blob/master/src/cljfx/ext/table_view.clj][cljfx source ext/table_view.clj]], says that we should pass the same value as from table-view's items.

Now we have an issue: we need the complete table data to select a row in the table-view.  But we store only the table_name in /:selected-table/ in our state.

We could write a new subscription that returns the full table data for the selected table name. However, I love the KISS principle.  And I see no particular reason to save only the table_name in /:selected-table/.  From now on, we'll store the complete table data.

Thus we need to change the handler for /:select-table/
#+begin_src clojure
(defmethod event-handler :select-table [{:keys [fx/context fx/event]}]
  (println ":select-table --> " (:table-name event))
  {:context (fx/swap-context context assoc :selected-table event)});;--- SAVE FULL EVENT(=TABLE DATA) ---
#+end_src

And also the /:select-visible-table/ event.

#+begin_src clojure
(defmethod event-handler :select-visible-table [{:keys [fx/context fx/event]}]
  (let [table (fx/sub-ctx context subs-visible-table-to-select)]
    (println ":select-visible-table --> table = " (:table_name table))
    {:context (fx/swap-context context assoc :selected-table table)}));;--- SAVE FULL TABLE DATA ---
#+end_src

For the /columns-view/ we need to extract just the table name.
#+begin_src clojure
(defn columns-view [{:keys [fx/context]}]
  {:fx/type :v-box
   :children [{:fx/type :label
               :text (str "Columns for table: "
                          (:table_name (fx/sub-val context :selected-table)))}]});;--- ONLY TABLENAME ---
#+end_src

(Remember: we changed a view procedure so you must execute /(renderer)/ in the REPL to see the changes)

Now we can use the /:selected-item/ property on the /table-view/ to automatically select the table in the table-view based on the value in the state's /:selected-table/
#+begin_src clojure
(defn tables-view [{:keys [fx/context]}]
  {:fx/type :v-box
   :children [;; ...
              {:fx/type fx.ext.table-view/with-selection-props
               :props {:selection-mode :single
                       :on-selected-item-changed {:event/type :select-table}
                       :selected-item (fx/sub-val context :selected-table)};;--- SHOW SELECTED TABLE ---
               :desc {:fx/type :table-view
                      ;; ...
                      }}]})
#+end_src

***** 12.5 Improve User Experience
There is still an inconvenience.

Suppose we have an empty filter.  And we select the table /t_customer_address/.
[[file:si-step12-50.png]]

If we now type /cus/ in the filter text edit, the first visible table /t_customer/ gets selected.

[[file:si-step12-51.png]]

This is a bit annoying because we previously selected /t_customer_address/. Because that selected table also occurs after filtering I expect that table to remain selected.

All we have to do is change /subs-visible-table-to-select/ to return the current selected table if that is still present in the new filtered list. Only if the current selected table is not in the new filtered list we return the first table from the list.



#+begin_src clojure
(defn subs-visible-table-to-select
  "Return the table from the visible table list that must be selected"
  [context]
  (let [tables (fx/sub-ctx context subs-filtered-tables)
        first-table (first tables)
        selected-table (fx/sub-val context :selected-table)
        contains-selected-table (some? (some #(= (:table_name selected-table) (:table_name %)) tables)) ]
    (println "subs-visible-table-to-select (contains-selected-table = " contains-selected-table ")")
    (if contains-selected-table
                             selected-table
                             first-table)))
#+end_src
**** Step 13 - Show the columns
Now we can show the columns.
***** 13.1 New state
We need a placeholder for the columns in the state.
#+begin_src clojure
(def *state
  (atom (fx/create-context
         {:table-filter ""
          :selected-table ""
          :tables []
          :columns-for-selected-table []};;--- NEW KEY FOR COLUMNS ---
         cache/lru-cache-factory)))
#+end_src

***** 13.2 Event to refresh columns
Now we need a new event to refresh the columns:
#+begin_src clojure
(defmethod event-handler :refresh-columns [{:keys [fx/context table]}]
  (println ":refresh-columns for table" (:table_name table)))
#+end_src

Whenever we select a table, either manually or because the filter changed, we must call this new event.

#+begin_src clojure
(defmethod event-handler :select-table [{:keys [fx/context fx/event]}]
  (println ":select-table --> " (:table_name event))
  {:context (fx/swap-context context assoc :selected-table event)
   :dispatch {:event/type :refresh-columns :table event}});;--- CALL NEW EVENT ---

(defmethod event-handler :select-visible-table [{:keys [fx/context fx/event]}]
  (let [table (fx/sub-ctx context subs-visible-table-to-select)]
    (println ":select-visible-table --> table = " (:table_name table))
    {:context (fx/swap-context context assoc :selected-table table)
     :dispatch {:event/type :refresh-columns :table table}}));;--- CALL NEW EVENT ---
#+end_src

When we manually select a table for instance /t_address_type/ we see in the output that the new event is called.  When we enter a filter, like typing /"c"/ for instance, the table /t_customer/ gets automatically selected.  And here too we see the new event in the output.
#+begin_src  clojure
;; The output is:
;;
;; :select-table -->  t_address_type
;; :refresh-columns for table t_address_type ;;--- OUTPUT OF THE NEW EVENT ---
;; :update-table-filter ---> c
;; subs-visible-table-to-select (contains-selected-table =  false )
;; :select-visible-table --> table =  t_customer
;; :refresh-columns for table t_customer;;--- OUTPUT OF THE NEW EVENT ---
#+end_src
***** 13.3 Side effect
We can now retrieve the columns from the database.

Because we don't want side effects in the event, we'll return a new effect instead.  And that effect will then actually retrieve the columns.

Please have a look at the documentation [[https://github.com/cljfx/cljfx#event-handling-on-steroids][cljfx doc: Event handling on steroids]].

We'll do something similar like the /:http effect/ from [[https://github.com/cljfx/cljfx/blob/master/examples/e18_pure_event_handling.clj][examples/e18_pure_event_handling.clj]]. That /:http effect/ is then used in [[https://github.com/cljfx/cljfx/blob/master/examples/e18_pure_event_handling/events.clj][examples/e18_pure_event_handling/events.clj]].

First we have to define a new effect /:retrieve-columns/. That effect will call the function /retrieve-columns-effect/ that will load the columns from database. (But for testing we currently just do a /println/)
#+begin_src clojure
;;--- NEW FUNCTION ---
(defn retrieve-columns-effect [table dispatch!]
  (println "retrieve-columns-effect " table))

(def map-event-handler
    (-> event-handler
        (fx/wrap-co-effects
         {:fx/context (fx/make-deref-co-effect *state)})
        (fx/wrap-effects
         {:context (fx/make-reset-effect *state)
          :dispatch fx/dispatch-effect
          ;;--- CREATE NEW EFFECT ---
          :retrieve-columns retrieve-columns-effect })))
#+end_src

Next change the /:refresh-columns/ event to return that effect.  At the same time we'll clear the columns.  Reason: when the database is slow, at least we won't see the columns of a previous table.
#+begin_src clojure
(defmethod event-handler :refresh-columns [{:keys [fx/context table]}]
  (println ":refresh-columns for table" (:table_name table))
  {;; Clear existing columns
   :context (fx/swap-context context assoc :columns-for-selected-table [])
   ;; Return an effect to actually retrieve the columns
   :retrieve-columns (fx/sub-val context :selected-table)})
#+end_src

If we click on a table we'll see that the side-effect function /retrieve-columns-effect/ is correctly called right after the /:refresh-columns/ event.

#+begin_src clojure
;; :select-table -->  t_customer
;; :refresh-columns for table t_customer
;; retrieve-columns-effect  {:table_name t_customer, :create_date #inst "2022-03-25T21:02:13.880000000-00:00", :modify_date #inst "2022-03-25T21:16:14.677000000-00:00"}
#+end_src

***** 13.4 Retrieve columns
The /effect/ mechanism is working. Time to actually retrieve the columns.

However, we first need a way to pass the data to the application's state. This is via a new event /:set-columns/.
#+begin_src clojure
(defmethod event-handler :set-columns [{:keys [fx/context columns]}]
  (println ":set-columns " columns)
  {:context (fx/swap-context context assoc :columns-for-selected-table columns)})
#+end_src

Our /effect/ should emit that event /:set-columns/ via the /dispatch!/ function that we get as a parameter. The columns are retrieved via the DB function /retrieve-table-columns/ we created way back in /Part 1/.

#+begin_src clojure
(defn retrieve-columns-effect [table dispatch!]
  (println "retrieve-columns-effect " table)
  (dispatch! {:event/type :set-columns
              :columns (retrieve-table-columns (:table_name table))}))
#+end_src

***** 13.5 It's showtime
The last step is to visualize the columns.

We'll use a table-view just like we did with the tables. Just one caveat: if the column type is one of /int, bit, date, datetime/ we don't show the size of the field.
#+begin_src clojure
(defn columns-view [{:keys [fx/context]}]
  {:fx/type :v-box
   :children [{:fx/type :label
               :text (str "Columns for table: "
                          (:table_name (fx/sub-val context :selected-table)))}
              {:fx/type fx.ext.table-view/with-selection-props
               :props {:selection-mode :multiple}
               :desc {:fx/type :table-view
                      :columns [{:fx/type :table-column
                                 :text "#"
                                 :cell-value-factory identity
                                 :cell-factory {:fx/cell-type :table-cell
                                                :describe (fn [column-data]
                                                            (println "Data for cell is:" column-data)
                                                            {:text (str(:column_id column-data))})}}
                                {:fx/type :table-column
                                 :text "Column"
                                 :cell-value-factory identity
                                 :cell-factory {:fx/cell-type :table-cell
                                                :describe (fn [column-data] {:text (:column_name column-data)})}}
                                {:fx/type :table-column
                                 :text "Type"
                                 :cell-value-factory identity
                                 :cell-factory {:fx/cell-type :table-cell
                                                :describe (fn [column-data] {:text (:type_name column-data)})}}
                                {:fx/type :table-column
                                 :text "Size"
                                 :cell-value-factory identity
                                 :cell-factory {:fx/cell-type :table-cell
                                                :describe (fn [column-data]
                                                            (let [types-with-no-size #{"int" "bit" "date" "datetime"}
                                                                  hide-size (some? (some #(= (:type_name column-data) %) types-with-no-size))
                                                                  value (if (true? hide-size)
                                                                          ""
                                                                          (str (:max_length column-data)))]
                                                              {:text value}))}}]
                      :items (fx/sub-val context :columns-for-selected-table)}}]})
#+end_src


Let's see how this looks so far:
[[file:si-step13-50.png]]

This concludes the third part of the series.  What we now have is an application that you can use for your own.

It is however not yet ready to be released in the wild.  Some improvements that are needed:
- This is not an app with the best looks
- Database connection is hardcoded
- Only one type of database is supported


  

* Footnotes
* COMMENT Local Variables                          :ARCHIVE:
# Local Variables:
# eval: (org-hugo-auto-export-mode)
# End:
